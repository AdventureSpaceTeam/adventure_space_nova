using System.Numerics;
using Content.Shared._Adventure.Medical.Surgery;
using Content.Shared._Adventure.Medical.Surgery.Components;
using Content.Shared.Body.Organ;
using Content.Shared.Body.Part;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;

namespace Content.Client._Adventure.Medical.Surgery.UI;

[GenerateTypedNameReferences]
public sealed partial class SurgeryWindow : DefaultWindow
{
    [Dependency] private readonly IPrototypeManager _prototypeManager = default!;
    [Dependency] private readonly IEntityManager _entityManager = default!;
    public event Action<BaseButton.ButtonEventArgs, SurgerySlotButton>? OnSurgerySlotButtonPressed;
    public event Action<BaseButton.ButtonEventArgs, OrganSlotButton>? OnOrganSlotButtonPressed;
    public static int DefaultButtonSize = 112;

    private static readonly string BasePath = "/Textures/DarkStation/MainGame/Interface/Default/SurgerySlots/";
    private static readonly string CauterisedIcon = BasePath + "Cauterised_Icon";
    private static readonly string BleedingIcon = BasePath + "Bleeding_Icon";
    private static readonly string FallBackIcon = BasePath + "Fallback_Icon";
    private static readonly string FallBackSlotOrPart = BasePath + "Fallback_Part";

    /// <summary>
    ///
    /// </summary>
    public SurgeryWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
    }

    private string GetPartStatusStr(SurgeryBodyPartComponent part, SharedPartStatus status)
    {
        if (status.Opened && part.Container) //
            return "_opened";
        if (status.EndoOpened && part.State.EndoSkeleton)
            return "_endo_open";
        if (status.Retracted && part.State.Incisable)
            return "_retracted";
        if (status.Incised && part.State.Incisable)
            return "_incised";
        if (status.ExoOpened && part.State.ExoSkeleton)
            return "_exo_opened";
        return "";
    }

    //TODO probably should use an actual visualiser here but it works for now
    private string FormatState(string symmetry, string type, string status)
    {
        var symString = "";

        if (symmetry == "Left")
            symString = "l_";
        else if (symmetry == "Right")
            symString = "r_";

        return symString + type.ToLower() + status + "_icon";
    }

    /// <summary>
    /// Adding body part slots to interface, part slot buttons are assigned to rows based on their type
    /// </summary>
    public void UpdateSurgeryMenu(SurgeryBoundUserInterfaceState state)
    {
        SurgeryLayout.Children.Clear();
        var bodyPartSlotList = new BodyPartSlotList();
        var slotParts = state.SlotPartsStatus;

        var headWingSlotsRow = new SurgerySlotRow();
        var headWingSlotButtons = new List<SlotButtonContainer>();

        var armTorsoSlotsRow = new SurgerySlotRow();
        var armTorsoSlotButtons = new List<SlotButtonContainer>();

        var handOtherSlotsRow = new SurgerySlotRow();
        var handOtherSlotButtons = new List<SlotButtonContainer>();

        var legTailSlotsRow = new SurgerySlotRow();
        var legTailSlotButtons = new List<SlotButtonContainer>();

        var footSlotsRow = new SurgerySlotRow();
        var footSlotButtons = new List<SlotButtonContainer>();

        var slotButtons = new List<SlotButtonContainer>();

        var partOrgans = new Dictionary<string, OrganSlotCol>();

        foreach (var bodyPartSlot in state.BodyPartSlots)
        {
            var iconRow = new SlotButtonIconRow();

            var typeVal = bodyPartSlot.Type ?? BodyPartType.Other;
            var slotType = typeVal.ToString();

            var buttonContainer = new SlotButtonContainer(bodyPartSlot, slotType);
            var button = new SurgerySlotButton(bodyPartSlot, slotType);
            button.OnPressed += args => OnSurgerySlotButtonPressed?.Invoke(args, button);

            var attachmentUid = _entityManager.GetEntity(bodyPartSlot.Attachment);

            var cautIcon = new SlotIconContainer("Cauterised");
            var attchIcon = new SlotIconContainer("Attachment");
            var bleedIcon = new SlotIconContainer("Bleeding");

            if (attachmentUid is not null)
            {
                if (_entityManager.HasComponent<SpriteComponent>(attachmentUid))
                {
                    var attachmentSprite = new StatusIconSprite();
                    attachmentSprite.SetEntity(attachmentUid);
                    attchIcon.Children.Add(attachmentSprite);
                }
            }

            if (bodyPartSlot.Cauterised)
            {
                cautIcon.TextureNormal = Theme.ResolveTexture(CauterisedIcon);
            }

            var partUid = _entityManager.GetEntity(bodyPartSlot.BodyPart);
            if (!bodyPartSlot.Cauterised && attachmentUid is null && partUid is null) //this is currently assuming any attachment will prevent bleeding... which is fine for now but may need to change
            {
                bleedIcon.TextureNormal = Theme.ResolveTexture(BleedingIcon);
            }

            iconRow.Children.Add(attchIcon);
            iconRow.Children.Add(cautIcon);
            iconRow.Children.Add(bleedIcon);

            if (partUid is not null)
            {
                if (_entityManager.TryGetComponent<BodyPartComponent?>(partUid, out var bodyPart))
                    buttonContainer.Symmetry = bodyPart.Symmetry.ToString();

                if (!_entityManager.TryGetComponent<SurgeryBodyPartComponent?>(partUid, out var surgeryBodyPart))
                    continue;

                if (_entityManager.TryGetComponent<SpriteComponent?>(partUid, out var sprite))
                {
                    var bodyPartSprite = new BodyPartSprite();
                    if (surgeryBodyPart != null && bodyPart is not null && bodyPartSlot.BodyPart != null && slotParts.TryGetValue(bodyPartSlot.BodyPart.Value, out var slotValue))
                    {
                        var status = GetPartStatusStr(surgeryBodyPart, slotValue);
                        sprite.LayerSetState(0, FormatState(bodyPart.Symmetry.ToString(), slotType, status));
                    }

                    bodyPartSprite.SetEntity(_entityManager.GetEntity(bodyPartSlot.BodyPart)!.Value);

                    button.Children.Add(bodyPartSprite);
                }
            }

            buttonContainer.Children.Add(iconRow);
            buttonContainer.Children.Add(button);

            slotButtons.Add(buttonContainer);
        }

        for (var i = 0; i < slotButtons.Count; i++)
        {
            //symmetrical part types are added to the start/end of list, rest are placed in centre
            //TODO assign symmetry via part slot
            void AddToSlotRow(SlotButtonContainer button, List<SlotButtonContainer> list, bool symmetry)
            {
                if (!symmetry)
                {
                    var index = (list.Count + 1) / 2;
                    list.Insert(index, button);
                }
                else
                {
                    var counterpartFound = false;
                    for (var j = 0; j < list.Count; j++)
                    {
                        if (list[j].SlotType == button.SlotType && !list[j].Counterpart)
                        {
                            counterpartFound = true;
                            if (button.Symmetry == "Left") //if we have assigned a left value from the constituent body part above, it overrides here
                            {
                                list.Insert(0, button);
                                break;
                            }
                            else
                            {
                                button.Symmetry = "Right"; //right now we are assuming left is always found first, followed by right... this is not necessarily correct //TODO fix by assigning symmetry to the slot
                                button.Counterpart = true;
                                if (list.Count > 0)
                                    list.Insert(list.Count - (j - 1), button);
                                else
                                    list.Insert(0, button);
                                break;
                            }
                        }
                    }

                    if (!counterpartFound)
                    {
                        if (button.Symmetry == "Right") //if we have assigned a right value from the constituent body part above, it overrides here
                        {
                            button.Counterpart = true;
                            if (list.Count > 0)
                                list.Insert(list.Count - 1, button); //TODO fix still not ideal but better than assuming its position, just wouldn't work on something with four arms as well
                            else
                                list.Insert(0, button);
                        }
                        else
                        {
                            button.Symmetry = "Left"; //TODO fix
                            button.Counterpart = true;
                            list.Insert(0, button);
                        }
                    }
                }
            }

            switch (slotButtons[i].SlotType)
            {
                case "Head":
                    AddToSlotRow(slotButtons[i], headWingSlotButtons, false);
                    break;
                case "Wing":
                    AddToSlotRow(slotButtons[i], headWingSlotButtons, true);
                    break;
                case "Torso":
                    AddToSlotRow(slotButtons[i], armTorsoSlotButtons, false);
                    break;
                case "Arm":
                    AddToSlotRow(slotButtons[i], armTorsoSlotButtons, true);
                    break;
                case "Hand":
                    AddToSlotRow(slotButtons[i], handOtherSlotButtons, true);
                    break;
                case "Leg":
                    AddToSlotRow(slotButtons[i], legTailSlotButtons, true);
                    break;
                case "Foot":
                    AddToSlotRow(slotButtons[i], footSlotButtons, true);
                    break;
                case "Tail":
                    AddToSlotRow(slotButtons[i], legTailSlotButtons, false);
                    break;
                default: //other
                    AddToSlotRow(slotButtons[i], handOtherSlotButtons, false);
                    break;
            }
        }

        for (var i = 0; i < headWingSlotButtons.Count; i++)
            headWingSlotsRow.Children.Add(headWingSlotButtons[i]);

        for (var i = 0; i < armTorsoSlotButtons.Count; i++)
            armTorsoSlotsRow.Children.Add(armTorsoSlotButtons[i]);

        for (var i = 0; i < handOtherSlotButtons.Count; i++)
            handOtherSlotsRow.Children.Add(handOtherSlotButtons[i]);

        for (var i = 0; i < legTailSlotButtons.Count; i++)
            legTailSlotsRow.Children.Add(legTailSlotButtons[i]);

        for (var i = 0; i < footSlotButtons.Count; i++)
            footSlotsRow.Children.Add(footSlotButtons[i]);

        bodyPartSlotList.Children.Add(headWingSlotsRow);
        bodyPartSlotList.Children.Add(armTorsoSlotsRow);
        bodyPartSlotList.Children.Add(handOtherSlotsRow);
        bodyPartSlotList.Children.Add(legTailSlotsRow);
        bodyPartSlotList.Children.Add(footSlotsRow);

        for (var i = 0; i < state.OrganSlots.Count; i++)
        {
            //create button
            var iconRow = new SlotButtonIconRow();
            var buttonContainer = new OrganSlotButtonContainer();

            var typeVal = state.OrganSlots[i].Type ?? OrganType.Other;

            var organSlotType = typeVal.ToString();
            var button = new OrganSlotButton(state.OrganSlots[i], organSlotType);
            button.OnPressed += args => OnOrganSlotButtonPressed?.Invoke(args, button);

            var attachmentUid = state.OrganSlots[i].Attachment;

            var cautIcon = new SlotIconContainer("Cauterised");
            var attchIcon = new SlotIconContainer("Attachment");
            var bleedIcon = new SlotIconContainer("Bleeding");

            if (attachmentUid is not null)
            {
                if (IoCManager.Resolve<IEntityManager>().TryGetComponent<SpriteComponent?>(_entityManager.GetEntity(state.OrganSlots[i].Attachment), out var isprite))
                {
                    var attachmentSprite = new StatusIconSprite();
                    attachmentSprite.SetEntity(_entityManager.GetEntity(state.OrganSlots[i].Attachment));

                    attchIcon.Children.Add(attachmentSprite);
                }
            }

            if (state.OrganSlots[i].Cauterised)
            {
                cautIcon.TextureNormal = Theme.ResolveTexture(CauterisedIcon);
            }

            if (!state.OrganSlots[i].Cauterised && attachmentUid is null && state.OrganSlots[i].Child is null)
            {
                bleedIcon.TextureNormal = Theme.ResolveTexture(BleedingIcon);
            }

            iconRow.Children.Add(attchIcon);
            iconRow.Children.Add(cautIcon);
            iconRow.Children.Add(bleedIcon);

            //add button sprite
            if (state.OrganSlots[i].Child != null && IoCManager.Resolve<IEntityManager>().TryGetComponent<SpriteComponent?>(_entityManager.GetEntity(state.OrganSlots[i].Child), out var sprite))
            {
                var organSprite = new BodyPartSprite();
                organSprite.SetEntity(_entityManager.GetEntity(state.OrganSlots[i].Child));
                button.Children.Add(organSprite);
            }

            if (!partOrgans.ContainsKey(state.OrganSlots[i].Parent.ToString()))
            {
                partOrgans.Add(state.OrganSlots[i].Parent.ToString(), new OrganSlotCol());
                if (slotParts.ContainsKey(state.OrganSlots[i].Parent))
                    partOrgans[state.OrganSlots[i].Parent.ToString()].Children.Add(new Label {Text = slotParts[state.OrganSlots[i].Parent].PartType.ToString()});
                ;
            }

            buttonContainer.Children.Add(iconRow);
            buttonContainer.Children.Add(button);

            //add button to dict
            partOrgans[state.OrganSlots[i].Parent.ToString()].Children.Add(buttonContainer);
        }

        SurgeryLayout.Children.Add(bodyPartSlotList);
        //iterate partOrgans, add cols to surgery menu
        var width = 625;
        foreach (KeyValuePair<string, OrganSlotCol> entry in partOrgans)
        {
            width += 100;
            SurgeryLayout.Children.Add(new Padding());
            SurgeryLayout.Children.Add(entry.Value);
        }

        SetSize = new Vector2(width, 675);
    }

    /// <summary>
    /// Update the UI state when new state data is received from the server.
    /// </summary>
    /// <param name="state">State data sent by the server.</param>
    public void UpdateState(BoundUserInterfaceState state)
    {
        var castState = (SurgeryBoundUserInterfaceState) state;
        UpdateSurgeryMenu(castState);
    }

    public sealed class SlotButtonContainer : BoxContainer
    {
        public BodyPartSlot Slot { get; }
        public string Symmetry = "None";
        public bool Counterpart = false;
        public string SlotType { get; }

        public SlotButtonContainer(BodyPartSlot slot, string slotType)
        {
            Slot = slot;
            SlotType = slotType;
            Orientation = LayoutOrientation.Horizontal;
            Align = AlignMode.Center;
        }
    }

    public sealed class OrganSlotButtonContainer : BoxContainer
    {
        public OrganSlotButtonContainer()
        {
            Orientation = LayoutOrientation.Horizontal;
            Align = AlignMode.Center;
        }
    }

    public sealed class SlotButtonIconRow : BoxContainer
    {
        public SlotButtonIconRow()
        {
            Orientation = LayoutOrientation.Vertical;
        }
    }

    public sealed class SlotIconContainer : TextureButton
    {
        public SlotIconContainer(string iconType)
        {
            MinSize = new Vector2(DefaultButtonSize / 3, DefaultButtonSize / 3);
            MaxSize = new Vector2(DefaultButtonSize / 3, DefaultButtonSize / 3);

            if (Theme.TryResolveTexture(BasePath + iconType, out var texture))
                TextureNormal = texture;
            else
                TextureNormal = Theme.ResolveTexture(FallBackIcon);
        }
    }

    public sealed class SurgerySlotButton : TextureButton
    {
        public BodyPartSlot Slot { get; }
        public string SlotType { get; }

        public SurgerySlotButton(BodyPartSlot slot, string slotType)
        {
            Slot = slot;
            SlotType = slotType;
            MinSize = new Vector2(DefaultButtonSize, DefaultButtonSize);
            MaxSize = new Vector2(DefaultButtonSize, DefaultButtonSize);

            if (Theme.TryResolveTexture(BasePath + SlotType, out var texture))
                TextureNormal = texture;
            else
                TextureNormal = Theme.ResolveTexture(FallBackIcon);
        }
    }

    public sealed class OrganSlotButton : TextureButton
    {
        public OrganSlot Slot { get; }
        public string SlotType { get; }

        public OrganSlotButton(OrganSlot slot, string slotType)
        {
            Slot = slot;
            SlotType = slotType;
            MinSize = new Vector2(DefaultButtonSize, DefaultButtonSize);
            MaxSize = new Vector2(DefaultButtonSize, DefaultButtonSize);

            if (Theme.TryResolveTexture(BasePath + SlotType, out var texture))
                TextureNormal = texture;
            else
                TextureNormal = Theme.ResolveTexture(FallBackIcon);
        }
    }

    public sealed class Padding : Control
    {
        public Padding()
        {
            MinSize = new Vector2(0, 10);
        }
    }

    public sealed class SurgerySlotRow : BoxContainer
    {
        public SurgerySlotRow()
        {
            Orientation = LayoutOrientation.Horizontal;
            Align = AlignMode.Center;
        }
    }

    public sealed class BodyPartSlotList : BoxContainer
    {
        public BodyPartSlotList()
        {
            Orientation = LayoutOrientation.Vertical;
            HorizontalExpand = true;
        }
    }

    public sealed class OrganSlotCol : BoxContainer
    {
        public OrganSlotCol()
        {
            Orientation = LayoutOrientation.Vertical;
            Align = AlignMode.Center;
        }
    }

    public sealed class BodyPartSprite : SpriteView
    {
        public BodyPartSprite()
        {
            OverrideDirection = Direction.South;
            Scale = new Vector2(3, 3);
        }
    }

    public sealed class StatusIconSprite : SpriteView
    {
        public StatusIconSprite()
        {
            OverrideDirection = Direction.South;
            Scale = new(2, 2);
        }
    }
}
